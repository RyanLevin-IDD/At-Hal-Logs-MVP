function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    
    // Validate payload
    if (!data.sheetName || !data.headers || !data.rows) {
      return ContentService
        .createTextOutput(JSON.stringify({ status: "error", message: "Missing required fields" }))
        .setMimeType(ContentService.MimeType.JSON);
    }

    // Process async to return quickly
    handleUrlLogsAsync(data);

    return ContentService
      .createTextOutput(JSON.stringify({ status: "received", rowsCount: data.rows.length }))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    return ContentService
      .createTextOutput(JSON.stringify({ status: "error", message: err.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function handleUrlLogsAsync(data) {
  handleUrlLogs(data);
}

function handleUrlLogs(data) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  let tabName = data.sheetName;
  const headers = data.headers;
  const rows = data.rows;
  const startIndex = data.startIndex || 0;

  if (tabName.startsWith("Logs-")) {
    tabName = tabName.substring(5);
  }

  // Get or create the sheet
  let tab = sheet.getSheetByName(tabName);
  if (!tab) {
    tab = sheet.insertSheet(tabName);
  }

  // Ensure headers exist
  ensureHeadersExist(tab, headers);

  if (rows.length === 0) return;

  if (startIndex <= 0) {
    // Normal append
    tab.getRange(tab.getLastRow() + 1, 1, rows.length, rows[0].length)
      .setValues(rows);
  } else {
    // Overwrite starting at startIndex
    const lastRow = tab.getLastRow();
    const neededRows = Math.max(rows.length, lastRow - startIndex + 1);

    // Clear existing rows that will be overwritten, if any
    tab.getRange(startIndex, 1, neededRows, tab.getLastColumn()).clearContent();

    // Write new data
    tab.getRange(startIndex, 1, rows.length, rows[0].length).setValues(rows);
  }
}

function ensureHeadersExist(tab, requiredHeaders) {
  isHeadersTheSame = isHeadersTheSame(tab,requiredHeaders);
  if (isHeadersTheSame) {return;}
  else
  {
    tab.getRange(1, 1, 1, requiredHeaders.length).setValues([requiredHeaders]);
    colorHeaderRow(tab, requiredHeaders.length);
  }
}

function isHeadersTheSame(tab, requiredHeaders) {
  const lastCol = tab.getLastColumn();
  if (lastCol !== requiredHeaders.length) return false;

  const existingHeaders = tab.getRange(1, 1, 1, lastCol).getValues()[0];

  for (let i = 0; i < requiredHeaders.length; i++) {
    if (existingHeaders[i] !== requiredHeaders[i]) {
      return false;
    }
  }

  return true;
}

function colorHeaderRow(tab, headerCount) {
  //Color first 8 columns in blue
  if (headerCount >= 8) {
    tab.getRange(1, 1, 1, 8).setBackground("#93CCEA");
  } else {
    tab.getRange(1, 1, 1, headerCount).setBackground("#93CCEA");
  }
  
  //Color remaining columns in light green
  if (headerCount > 8) {
    tab.getRange(1, 9, 1, headerCount - 8).setBackground("#b6d7a8");
  }
}
