//ENDPOINTS

function doGet(e) {//GET request - This Send the names of the domains from the Domains List tab
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet();
    const tab = sheet.getSheetByName("Domains List");

    if (!tab) {
      return ContentService.createTextOutput(
        JSON.stringify({ status: "error", message: "'Domains List' sheet not found" })
      ).setMimeType(ContentService.MimeType.JSON);
    }

    // Get all values in column 1 starting from row 2 (skip header)
    const data = tab.getRange(2, 1, tab.getLastRow() - 1, 1).getValues();

    // Flatten the array to a list of strings
    const domains = data.map(row => row[0]).filter(name => name); //remove empty rows

    return ContentService.createTextOutput(
      JSON.stringify({ status: "success", domains: domains })
    ).setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    return ContentService.createTextOutput(
      JSON.stringify({ status: "error", message: err.message })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}

function doPost(e) {//POST request - This recives the JSON logs
  try {
    const data = JSON.parse(e.postData.contents);

    // Process async
    if (data.results && data.domain) {
      // Get response data BEFORE processing
      const responseData = getLogTrackingData(data);
      
      // Start async processing (doesn't wait for completion)
      handleAccessLogsAsync(data);
      
      // Send immediate response with last/first log info
      return ContentService
        .createTextOutput(JSON.stringify(responseData))
        .setMimeType(ContentService.MimeType.JSON);
        
    } else if (data.machineName && data.logs) {
      // Send immediate response
      const response = ContentService
        .createTextOutput(JSON.stringify({ status: "received" }))
        .setMimeType(ContentService.MimeType.JSON);
      
      handleMachineLogAsync(data);
      
      return response;
    }

    // Default response
    return ContentService
      .createTextOutput(JSON.stringify({ status: "received" }))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (err) {
    return ContentService
      .createTextOutput(JSON.stringify({ status: "error", message: err.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

//Adding raw data, seprated query parameters and Info logs to sheet
function handleAccessLogsAsync(data) {
  handleAccessLogs(data);
}
function handleMachineLogAsync(data) {
  handleMachineLog(data);
}
function handleAccessLogs(data) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  const domain = data.domain;
  const results = data.results;

  //Main sheet for access logs
  const mainSheetName = domain;
  let mainSheet = sheet.getSheetByName(mainSheetName);
  if (!mainSheet) mainSheet = sheet.insertSheet(mainSheetName);

  const baseHeaders = ["Time", "IP Address", "Request", "Device", "Country", "Size (bytes)", "Response time (ms)"];
  ensureColumnsExists(mainSheet, baseHeaders);

  // Append main rows
  const rows = results.map(obj => baseHeaders.map(h => obj[h] || ""));
  mainSheet.getRange(mainSheet.getLastRow() + 1, 1, rows.length, baseHeaders.length).setValues(rows);

  // Logs tab for URL parameters
  const logTabName = `Logs-${domain}`;
  let logSheet = sheet.getSheetByName(logTabName);
  if (!logSheet) logSheet = sheet.insertSheet(logTabName);

  //Ensure header exists
  ensureColumnsExists(logSheet, ["Request"]);

  //Collect requests
  const requestList = results.map(r => r["Request"]).filter(Boolean);

  processUrlLogs(logSheet, results, baseHeaders);

  return ContentService
    .createTextOutput(JSON.stringify({ status: "success", type: "access_logs", appended: rows.length }))
    .setMimeType(ContentService.MimeType.JSON);
}
function handleMachineLog(data) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  const tabName = "Info Logs";
  let tab = sheet.getSheetByName(tabName);
  if (!tab) {
    tab = sheet.insertSheet(tabName);
  }
  
  ensureColumnsExists(tab, ["Time", "Machine Name", "Log"]);
  const row = [formatTimeToString(new Date()), data.machineName, data.logs];
  tab.appendRow(row);

  return ContentService
    .createTextOutput(JSON.stringify({ status: "success", type: "machine_log", appended: 1 }))
    .setMimeType(ContentService.MimeType.JSON);
}

function processUrlLogs(logSheet, results, passedOriginalHeaders = null) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  const originalTab = getOriginalTab(logSheet);
  if (!originalTab) return;

  // Get or initialize headers
  let headers = [];
  let startRow = 2;
  
  if (logSheet.getLastRow() > 1) {
    // Headers already exist - pull them
    const lastCol = logSheet.getLastColumn();
    headers = logSheet.getRange(1, 1, 1, lastCol).getValues()[0];
    startRow = logSheet.getLastRow() + 1;
  } else {
    // First run - build initial headers
    const baseHeaders = passedOriginalHeaders || [];
    headers = ['Time Received', ...baseHeaders, 'Dev Request'];
    logSheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    logSheet.getRange(1, 1, logSheet.getMaxRows(), headers.length).setWrapStrategy(SpreadsheetApp.WrapStrategy.CLIP);
    // Color headers on first run
    const baseHeadersCount = (passedOriginalHeaders || []).length + 2;
    logSheet.getRange(1, 1, 1, baseHeadersCount).setBackground("#93CCEA");
    logSheet.getRange(1, 1).setBackground("#fff2cc");
  }

  // Build parameter headers list from columns 10+
  const paramHeaders = [];
  for (let i = 9; i < headers.length; i++) {
    paramHeaders.push(headers[i].toLowerCase());
  }

  // First pass: discover all new parameters and add columns
  results.forEach(result => {
    const url = result["Request"] || "";
    const cleanUrl = url.replace(/\s*HTTP\/[0-9.]+.*$/i, "");
    const [, queryString] = cleanUrl.split("?");
    
    if (queryString) {
      const params = queryString.split("&");
      const seenInThisUrl = new Set();
      
      params.forEach(param => {
        if (!param.includes("=")) return;
        
        let key = param.split("=")[0];
        key = decodeURIComponent(key).toLowerCase();
        
        // Check if parameter already exists in paramHeaders
        if (!paramHeaders.includes(key)) {
          // New parameter - add column
          headers.push(key);
          paramHeaders.push(key);
          logSheet.getRange(1, headers.length).setValue(key);
          logSheet.getRange(1, headers.length).setBackground("#b6d7a8");
        }
      });
    }
  });

  const finalHeaderMap = createHeaderMap(headers);

  // Second pass: populate all rows
  results.forEach(result => {
    const newRow = Array(headers.length).fill("");
    
    // Add timestamp
    const now = new Date();
    const formatted = Utilities.formatDate(now, Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm:ss');
    newRow[0] = formatted;
    
    // Add original data columns - fixed indices 1-8
    newRow[1] = result['Time'] || "";
    newRow[2] = result['IP Address'] || "";
    newRow[3] = result['Request'] || "";
    newRow[4] = result['Device'] || "";
    newRow[5] = result['Country'] || "";
    newRow[6] = result['Size (bytes)'] || "";
    newRow[7] = result['Response time (ms)'] || "";

    // Add Dev Request at index 8
    const url = result["Request"] || "";
    const cleanUrl = url.replace(/\s*HTTP\/[0-9.]+.*$/i, "");
    newRow[8] = cleanUrl;

    // Add parameter values
    const [, queryString] = cleanUrl.split("?");
    if (queryString) {
      const params = queryString.split("&");
      const processedInThisUrl = new Set();
      
      params.forEach(param => {
        if (!param.includes("=")) return;
        
        let [key, value] = param.split("=");
        key = decodeURIComponent(key).toLowerCase();
        
        // Write to parameter column if it exists
        if (key in finalHeaderMap) {
          value = decodeURIComponent(value || "");
          if (/^\d+(\.\d+)?$/.test(value)) {
            value = "'" + value;
          }
          newRow[finalHeaderMap[key]] = value;
        }
      });
    }

    // Write row to sheet
    logSheet.getRange(startRow, 1, 1, headers.length).setValues([newRow]);
    startRow++;
  });
}


//Error handling
function getLogTrackingData(data) { //returns the last row from prev run and the first of current run
  const domain = data.domain;
  const results = data.results;
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  let sheetName = domain;
  let tab = sheet.getSheetByName(sheetName);
  
  const baseHeaders = ["Time", "IP Address", "Request", "Device", "Country", "Size (bytes)", "Response time (ms)"];
  
  // Get previous last log if tab exists
  let previousLastLog = tab ? getPreviousLastLog(tab, baseHeaders) : null;
  
  // Format the Time field in previousLastLog to match incoming format
  if (previousLastLog && previousLastLog.Time) {
    previousLastLog.Time = formatTimeToString(previousLastLog.Time);
  }
  
  // Get current first log (first row of what we just received)
  const currentFirstLog = results.length > 0 ? results[0] : null;
  
  // Build response
  return {
    status: "received",
    previousLastLog: previousLastLog,
    currentFirstLog: currentFirstLog
  };
}
function getPreviousLastLog(tab, headers) {
  const lastRow = tab.getLastRow();
  
  // If only header row exists -> no previous log
  if (lastRow <= 1) {
    return null;
  }
  const lastRowData = tab.getRange(lastRow, 1, 1, headers.length).getValues()[0];
  
  // Build log
  const logObject = {};
  headers.forEach((header, index) => {
    logObject[header] = lastRowData[index];
  });
  
  return logObject;
}
function formatTimeToString(dateValue) {
  if (!dateValue) return "";
  
  // If it's already a string, return as-is
  if (typeof dateValue === 'string') return dateValue;
  
  // Convert Date object to formatted string
  const date = new Date(dateValue);
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const year = date.getFullYear();
  let hours = date.getHours();
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  
  return `${month}/${day}/${year} ${hours}:${minutes}:${seconds} ${ampm}`;
}

function hasDuplicateParameters(url) {//Checks if the url have the same parameters in diffren permutation
  const cleanUrl = url.replace(/\s*HTTP\/[0-9.]+.*$/i, "");
  const [, queryString] = cleanUrl.split("?");
  
  if (!queryString) return false;
  
  const paramKeys = new Set();
  const lowerCaseKeys = new Set();
  
  const params = queryString.split("&");
  
  for (const param of params) {
    if (!param.includes("=")) continue;
    
    let key = param.split("=")[0];
    key = decodeURIComponent(key).toLowerCase();
    
    if (lowerCaseKeys.has(key)) {
      return true; //Found duplicate
    }
    lowerCaseKeys.add(key);
  }
  
  return false; //No duplicates
}

//Logs Domain Sheet logic
function extractUrlParameters(results, originalHeaders) {
  const headerSet = new Set([...originalHeaders.map(h => h.toLowerCase()), "Request dev"]);
  const newParamKeys = new Set();
  
  results.forEach(result => {
    const url = result["Request"];
    if (!url) return;
    const cleanUrl = url.replace(/\s*HTTP\/1\.1.*$/i, "");
    const [, queryString] = cleanUrl.split("?");
    if (queryString) {
      const params = queryString.split("&");
      params.forEach(param => {
        const eqIndex = param.indexOf("=");
        if (eqIndex === -1) return;
        const key = decodeURIComponent(param.slice(0, eqIndex)).toLowerCase();
        if (!headerSet.has(key)) {
          newParamKeys.add(key);
        }
      });
    }
  });
  
  return newParamKeys;
}
function buildFinalHeaders(originalHeaders, newParamKeys) { 
  return [...originalHeaders, "Request dev", ...Array.from(newParamKeys)];
}
function parseResultRow(result, originalHeaders, headerMap, finalLength) { //returns the finished row for logs-domain tab
  const newRow = Array(finalLength).fill("");
  
  // Copy all base columns from result using the original header names
  originalHeaders.forEach(header => {
    const headerLower = header.toLowerCase();
    if (headerLower in headerMap) {
      newRow[headerMap[headerLower]] = result[header] || "";
    }
  });

  // Add full URL to Request dev column
  const url = result["Request"];
  if (url) {
    newRow[headerMap["Request dev"]] = url;
    const cleanUrl = url.replace(/\s*HTTP\/1\.1$/i, "");

    //Parse and add parameters
    const [_, queryString] = cleanUrl.split("?");
    if (queryString) {
      const params = queryString.split("&");
      params.forEach(param => 
      {
        if (!param.includes("=")) return;
        let [key, value] = param.split("=");
        key = decodeURIComponent(key).toLowerCase();
        value = decodeURIComponent(value || "");
        if (key in headerMap) {
        if (/^\d+(\.\d+)?$/.test(value)) {
          value = "'" + value;
        } else {
          value = value.toString();
        }
          newRow[headerMap[key]] = value;
        }
      });
    }
  }
  
  return newRow;
}
function duplicateResultsData(existingLogRows, existingLogHeaders, headerMap, finalLength) { //returns a copy of the raw result rows
  return existingLogRows.map(row => {
    const newRow = Array(finalLength).fill("");
    existingLogHeaders.forEach((header, idx) => {
      const headerLower = header.toLowerCase();
      if (headerLower in headerMap) {
        newRow[headerMap[headerLower]] = row[idx];
      }
    });
    return newRow;
  });
}

//Sheet actions
function colorLogHeaders(sheet, originalColumnCount, totalColumnCount) {
  //original columns
  sheet.getRange(1, 1, 1, originalColumnCount).setBackground("#93CCEA");
  sheet.getRange(1, 1).setBackground("#fff2cc");
  //parameter columns
  if (totalColumnCount > originalColumnCount) {
    sheet.getRange(1, originalColumnCount + 1, 1, totalColumnCount - originalColumnCount).setBackground("#b6d7a8");
  }
}
function ensureColumnsExists(sheet, requiredColumns) {
  let lastCol = sheet.getLastColumn();
  const headerRow = lastCol > 0 ? sheet.getRange(1, 1, 1, lastCol).getValues()[0] : [];

  requiredColumns.forEach(col => {
    if (!headerRow.includes(col)) {
      sheet.getRange(1, sheet.getLastColumn() + 1).setValue(col);
    }
  });
  sheet.getRange(1, 1, 1, requiredColumns.length).setBackground("#93CCEA");
}
function formatRowsWithTimestamp(row, headerMap) { // put timestamp in column A
  const now = new Date();
  const formatted = Utilities.formatDate(now, Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm:ss');
  row[headerMap['time received']] = formatted; 
  return row;
}
function getHeadersAndExistingRows(logSheet, originalTab) {
  const originalLastCol = originalTab.getLastColumn();
  const originalHeaders = originalLastCol > 0 ? originalTab.getRange(1, 1, 1, originalLastCol).getValues()[0] : [];

  const logLastRow = logSheet.getLastRow();
  const logLastCol = logSheet.getLastColumn();
  const existingLogRows = logLastRow > 1 && logLastCol > 0 ? logSheet.getRange(2, 1, logLastRow - 1, logLastCol).getValues() : [];
  const existingLogHeaders = logLastCol > 0 ? logSheet.getRange(1, 1, 1, logLastCol).getValues()[0] : [];

  return { originalHeaders, existingLogHeaders, existingLogRows };
}
function getOriginalTab(logSheet) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet();
  const originalTabName = logSheet.getName().replace('Logs-', '');
  const originalTab = sheet.getSheetByName(originalTabName);
  if (!originalTab) Logger.log("Original tab not found: " + originalTabName);
  return originalTab;
}
function writeRowsToSheet(sheet, startRow, rows, columnCount) {
  sheet.getRange(startRow, 1, rows.length, columnCount).setValues(rows);
}
function createHeaderMap(finalHeaders) {
  const headerMap = {};
  finalHeaders.forEach((h, idx) => headerMap[h.toLowerCase()] = idx);
  return headerMap;
}